--[[Auto Update]]--
local author = "Creative";
local SCRIPT_FILE_NAME = GetScriptName();
local SCRIPT_FILE_ADDR = "https://raw.githubusercontent.com/VngGodCreative/godcreative-lua/main/God%20Creative";
local VERSION_FILE_ADDR = "https://raw.githubusercontent.com/VngGodCreative/godcreative-lua/main/version%20update";
local VERSION_NUMBER = "2.1";
local version_check_done = false;
local update_downloaded = false;
local update_available = false;
local up_to_date = false;
local updaterfont1 = draw.CreateFont("Bahnschrift", 16);
local updaterfont2 = draw.CreateFont("Bahnschrift", 14);
local updateframes = 0;
local fadeout = 0;
local spacing = 0;
local fadein = 0;

callbacks.Register( "Draw", "handleUpdates", function()
	if updateframes < 5.5 then
		if up_to_date or updateframes < 0.25 then
			updateframes = updateframes + globals.AbsoluteFrameTime();
			if updateframes > 5 then
				fadeout = ((updateframes - 5) * 510);
			end
			if updateframes > 0.1 and updateframes < 0.25 then
				fadein = (updateframes - 0.1) * 4500;
			end
			if fadein < 0 then fadein = 0 end
			if fadein > 650 then fadein = 650 end
			if fadeout < 0 then fadeout = 0 end
			if fadeout > 255 then fadeout = 255 end
		end
		if updateframes >= 0.25 then fadein = 650 end
		for i = 0, 600 do
			local alpha = 200-i/3 - fadeout;
			if alpha < 0 then alpha = 0 end
			draw.Color(15,15,15,alpha);
			draw.FilledRect(i - 650 + fadein, 0, i+1 - 650 + fadein, 30);
			draw.Color(0, 180, 255,alpha);
			draw.FilledRect(i - 650 + fadein, 30, i+1 - 650 + fadein, 31);
		end
		draw.SetFont(updaterfont1);
		draw.Color(0,180,255,255 - fadeout);
		draw.Text(7 - 650 + fadein, 7, "GOD Creative ");
		draw.Color(225,225,225,255 - fadeout);
		draw.Text(7 + draw.GetTextSize("GOD Creative ") - 650 + fadein, 7, "Script");
		draw.Color(0,180,255,255 - fadeout);
		draw.Text(7 + draw.GetTextSize("GOD Creative Script ") - 650 + fadein, 7, "\\");
		spacing = draw.GetTextSize("GOD Creative Script  \\ ");
		draw.SetFont(updaterfont2);
		draw.Color(225,225,225,255 - fadeout);
	end

    if (update_available and not update_downloaded) then
		draw.Text(7 + spacing - 650 + fadein, 9, "Downloading latest version.");
        local new_version_content = http.Get(SCRIPT_FILE_ADDR);
        local old_script = file.Open(SCRIPT_FILE_NAME, "w");
        old_script:Write(new_version_content);
        old_script:Close();
        update_available = false;
        update_downloaded = true;
	end
	
    if (update_downloaded) and updateframes < 5.5 then
		draw.Text(7 + spacing - 650 + fadein, 9, "Update available, please reload Lua.");
    end

    if (not version_check_done) then
        version_check_done = true;
		local version = http.Get(VERSION_FILE_ADDR);
		version = string.gsub(version, "\n", "");
		if (version ~= VERSION_NUMBER) then
            update_available = true;
		else 
			up_to_date = true;
		end
	end
	
	if up_to_date and updateframes < 5.5 then
		draw.Text(7 + spacing - 650 + fadein, 9, "Successfully loaded latest version: v" .. VERSION_NUMBER);
	end
end)
--[[Auto Update End]]--

--[[GUI Stuff]]--
local misc_ref = gui.Reference("Misc")
local tab = gui.Tab(misc_ref, "GOD Creative ", ("GOD Creative v" .. VERSION_NUMBER))

local left_tab = gui.Groupbox(tab, "Watermark", 10, 15, 300)
local left_tab3 = gui.Groupbox(tab, "Misc", 10, 160, 300)
local right_tab = gui.Groupbox(tab, "Chat Command", 320, 15, 300)
local right_tab2 = gui.Groupbox(tab, "Troll Lobby", 320, 393, 300)
local right_tab3 = gui.Groupbox(tab, "Block Bot", 320, 652, 300)
local right_tab4 = gui.Groupbox(tab, "Spin Lobby", 320, 546, 300)
local rainbow_hudGroup = gui.Groupbox(tab, "Đổ màu HUD", 320,220,300)

local watermark = gui.Checkbox(left_tab, "enable.watermark", "Bật Watermark", false)
watermark:SetDescription("Turn on watermark Gamesense/Skeet.")
local ui_color = gui.ColorPicker(left_tab, "ui_color", "Màu Watermark", 125, 125, 230)
ui_color:SetDescription("Change color watermark.")

local key = gui.Keybox (left_tab3, "lua_keybox", "Nút chuyển đổi",0)
key:SetDescription("Change mode legit and ragebot.")
local doorspam = gui.Keybox(left_tab3, "doorspam", "Nút spam cửa", false)
doorspam:SetDescription("Make Door Spamming.")
local ui, f, n, aa = {danger = {fasthop = gui.Keybox(left_tab3, "danger.fasthop", "Bunny nhanh trong DangerZone", 0),},};
ui.danger.fasthop:SetDescription("Fast Bunnyhop on DangerZone")
local EngineRadar = gui.Checkbox(left_tab3, "engine.radar", "Bật Radar", false)
EngineRadar:SetDescription("You can see enemy on Radar.")
local ForceCrosshair = gui.Checkbox(left_tab3, "force.crosshair", "Tâm Súng Ngắm", false)
ForceCrosshair:SetDescription("Enable Crosshair on non-scope.")
local RecoilCrosshair = gui.Checkbox(left_tab3, "recoil.crosshair", "Tâm giật", false)
RecoilCrosshair:SetDescription("Crosshair aiming on Bullet.")
local UnlockInvAccess = gui.Checkbox(left_tab3, "unlockinvaccess", "Thay súng trong game", false)
UnlockInvAccess:SetDescription("Unlock Inventory on game.")
local vote_print_chat = (function() local on = gui.Checkbox(left_tab3, "showvote", "Hiện vote trên chat", false)
on:SetDescription("Print voting information in local client chat.")
local Ref = gui.Reference("Misc")
local Menu = {
    Enable = gui.Checkbox(left_tab3, "customtag", "Clantag tùy chỉnh", false),
    Mode = gui.Combobox(left_tab3, "customtag.mode", "Clantag mode", "Static", "Rotate", "Marquee", "Arabic"),
    Text = gui.Editbox(left_tab3, "customtag.text", ""),
}

local enable_chatcmds = gui.Checkbox(right_tab, "enable.chatcmds", "Bật Chat Commands", false)
local ranks_mode = gui.Combobox(right_tab, "ranks.mode", "Chọn kênh chat", "Chat Team", "Chat All")
local chat_commands = gui.Multibox(right_tab, "Select Chat Commands")
local enable_ranks = gui.Checkbox(chat_commands, "enable.ranks", "!ranks", 1)
local enable_roll = gui.Checkbox(chat_commands, "enable.roll", "!roll", 1)
local enable_8ball = gui.Checkbox(chat_commands, "enable.8ball", "!8ball", 1)
local enable_gaydar = gui.Checkbox(chat_commands, "enable.gaydar", "!gay", 1)
local enable_coin_flip = gui.Checkbox(chat_commands, "enable.flip", "!flip", 1)
local enable_anime = gui.Checkbox(chat_commands, "enable.anime", "!anime", 1)
local rainbowcheckbox = gui.Checkbox(rainbow_hudGroup, "enable", "Đổ màu đa sắc HUD",false)
rainbowcheckbox:SetDescription("Make HUD change Color.")
local rainbowslider = gui.Slider(rainbow_hudGroup, "interval", "Tốc độ màu HUD", 1, 0, 10, 0.05)
rainbowslider:SetDescription("Change Color Speed.")
--[[GUI Stuff End]]--

--[[Faceit End match]]--
--\02 do --\04 xanh la
--took ffi funktions from FFIChatVoteReveal.lua
local CHudChat_Printf_Index = 27
local ChatPrefix = "\02[\07Hit Log]\02 "
local function FindHudElement(name)
    local m_Table = mem.FindPattern("client.dll", "B9 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 46 24")
    local m_Function = mem.FindPattern("client.dll", "55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39")

    if m_Table ~= nil and m_Function ~= nil then
        return ffi.cast("void*(__thiscall*)(void*, const char*)", m_Function)(ffi.cast("void**", m_Table + 0x1)[0], name)
    end

    return nil
end
local CHudChat = FindHudElement("CHudChat")
if CHudChat == nil then
    error("CHudChat is nullptr.")
end
local CHudChat_Printf = ffi.cast("void(__cdecl*)(void*, int, int, const char*, ...)", ffi.cast("void***", CHudChat)[0][CHudChat_Printf_Index])
local function ChatPrint(msg)
    CHudChat_Printf(CHudChat, 0, 0, " " .. ChatPrefix .. msg)
end

-- Created by ArtzHarvest - https://aimware.net/forum/user/484354
local playerDamage = {}
local localPlayerIndex = client.GetLocalPlayerIndex()
callbacks.Register("FireGameEvent", "EventHook", function(e)
    local eventName = e:GetName()
    if eventName == 'round_announce_match_start' then
        playerDamage = {}
    end
    if eventName == "player_hurt" then
        local attacker = entities.GetByUserID(e:GetInt("attacker"))
        local victim = entities.GetByUserID(e:GetInt("userid"))
        if attacker and victim and attacker:IsPlayer() and victim:IsPlayer() then
            local attackerIndex = attacker:GetIndex()
            local victimIndex = victim:GetIndex()
            if attackerIndex == localPlayerIndex then
                if not playerDamage[victimIndex] then
                    playerDamage[victimIndex] = { damageDealt = 0, hitsDealt = 0, damageTaken = 0, hitsTaken = 0 }
                end

                playerDamage[victimIndex].damageDealt = playerDamage[victimIndex].damageDealt + e:GetInt("dmg_health")
                playerDamage[victimIndex].hitsDealt = playerDamage[victimIndex].hitsDealt + 1
            end
            if victimIndex == localPlayerIndex then
                if not playerDamage[attackerIndex] then
                    playerDamage[attackerIndex] = { damageDealt = 0, hitsDealt = 0, damageTaken = 0, hitsTaken = 0 }
                end

                playerDamage[attackerIndex].damageTaken = playerDamage[attackerIndex].damageTaken + e:GetInt("dmg_health")
                playerDamage[attackerIndex].hitsTaken = playerDamage[attackerIndex].hitsTaken + 1
            end
        end
    end
    if eventName == "round_end" then
        local localPlayer = entities.GetLocalPlayer()
        for index, damageInfo in pairs(playerDamage) do
            local player = entities.GetByIndex(index)
            if player and player:IsPlayer() then
                local playerName = player:GetName()
                local playerHealth = player:GetHealth() or 0

                local damageDealt = damageInfo.damageDealt or 0
                local hitsDealt = damageInfo.hitsDealt or 0
                local damageTaken = damageInfo.damageTaken or 0
                local hitsTaken = damageInfo.hitsTaken or 0

                if player:GetTeamNumber() ~= localPlayer:GetTeamNumber() then
                    local message = string.format("\04: [%d dmg / %d hits] - From: [%d dmg / %d hits] - %s (%d hp)", damageDealt, hitsDealt, damageTaken, hitsTaken, playerName, playerHealth)
                    ChatPrint(message)
                end
            end
        end
        playerDamage = {}
    end
end)
--[[Faceit End match End]]--

--[[PannoramaUtil]]--
panorama.RunScript([[
    var ep_globals = {
        
        handlers: {},

        elements: {},

        config: {
            prefix: '!',
            premium: true,
        },

        update_config: function(type, value) {
            ep_globals.config[type] = value;
        },

        symbols: {
            bullet: '\u{2022}',
            check: '\u{2714}',
            times: '\u{2716}',
            warning: '\u{26A0}',
            location: '\u{25BC}'
        },

        regex: {
            steamid64: /^(7656[0-9]{13})$/i,
            lobby_index: /^([1-9]{1})$/i,
            friend_code: /^(\w{5}-\w{4})$/i,
            competitive: /^(mm|comp.{0,7})$/i,
            wingman: /^(wm|wing.{0,3})$/i
        },

        locations: {
            AF: "Áp-ga-ni-xtan (Afghanistan)",
            AX: "Quần đảo Aland (Åland Islands)",
            AL: "anbani (Albania)",
            DZ: "An-giê-ri (Algeria)",
            AS: "American Samoa",
            AD: "Andorra",
            AO: "Ăng-gô-la (Angola)",
            AI: "Anguilla",
            AQ: "Nam Cực (Antarctica)",
            AG: "Antigua và Barbuda (Antigua and Barbuda)",
            AR: "Ác-hen-ti-na (Argentina)",
            AM: "Ác-mê-ni-a (Armenia)",
            AW: "Aruba",
            AU: "Châu Úc (Australia)",
            AT: "Áo (Austria)",
            AZ: "A-déc-bai-gian (Azerbaijan)",
            BS: "Bahamas",
            BH: "Bahrain",
            BD: "Băng-la-đét (Bangladesh)",
            BB: "Barbados",
            BY: "Bêlarut (Belarus)",
            BE: "nước Bỉ (Belgium)",
            BZ: "Belize",
            BJ: "Bénin (Benin)",
            BM: "Bermuda",
            BT: "Bu-tan (Bhutan)",
            BO: "Bôlivia (Bolivia)",
            BA: "Bosnia và Herzegovina (Bosnia and Herzegovina)",
            BW: "Botswana",
            BV: "Đảo Bouvet (Bouvet Island)",
            BR: "Brazil",
            IO: "Lãnh thổ Ấn Độ Dương thuộc Anh (British Indian Ocean Territory)",
            BN: "Vương quốc Bru-nây (Brunei Darussalam)",
            BG: "Bulgari (Bulgaria)",
            BF: "Burkina Faso",
            BI: "Burundi",
            KH: "Campuchia (Cambodia)",
            CM: "Cameroon",
            CA: "Camerun (Canada)",
            CV: "Mũi Verde (Cape Verde)",
            KY: "Quần đảo Cayman (Cayman Islands)",
            CF: "Cộng hòa trung phi (Central African Republic)",
            TD: "Tchad (Chad)",
            CL: "Chi-lê (Chile)",
            CN: "Trung Quốc (China)",
            CX: "Đảo giáng sinh (Christmas Island)",
            CC: "Quần đảo Cocos Keeling (Cocos Keeling Islands)",
            CO: "Cô-lôm-bi-a (Colombia)",
            KM: "Comoros",
            CG: "Công-gô (Congo)",
            CD: "Công-gô, Cộng hòa Dân chủ (Congo, The Democratic Republic)",
            CK: "Quần đảo Cook (Cook Islands)",
            CR: "Cô-xta Ri-ca (Costa Rica)",
            CI: "Bờ Biển Ngà (Cote D'Ivoire)",
            HR: "Croatia",
            CU: "Cuba",
            CY: "Síp (Cyprus)",
            CZ: "Cộng hòa Séc (Czech Republic)",
            DK: "Đan mạch (Denmark)",
            DJ: "Djibouti",
            DM: "Đô-mi-ni-ca (Dominica)",
            DO: "Cộng hòa Dominica (Dominican Republic)",
            EC: "Ecuador",
            EG: "Ai Cập (Egypt)",
            SV: "El Salvador",
            GQ: "Equatorial Guinea",
            ER: "Eritrea",
            EE: "Estonia",
            ET: "Ê-ti-ô-pi-a (Ethiopia)",
            FK: "Quần đảo Falkland Malvinas (Falkland Islands Malvinas)",
            FO: "Quần đảo Faroe (Faroe Islands)",
            FJ: "Fiji",
            FI: "Phần Lan (Finland)",
            FR: "Pháp (France)",
            GF: "Guiana thuộc Pháp (French Guiana)",
            PF: "Polynésie thuộc Pháp (French Polynesia)",
            TF: "Lãnh thổ phía Nam của Pháp (French Southern Territories)",
            GA: "Gabon",
            GM: "Gambia",
            GE: "Gruzia (Georgia)",
            DE: "Đức (Germany)",
            GH: "Gana (Ghana)",
            GI: "Gibraltar",
            GR: "Hy Lạp (Greece)",
            GL: "Vùng đất xanh (Greenland)",
            GD: "Grenada",
            GP: "Guadeloupe",
            GU: "Đảo Guam (Guam)",
            GT: "Goa-tê-ma-la (Guatemala)",
            GG: "Du kích (Guernsey)",
            GN: "Guinea",
            GW: "Guiné-Bissau (Guinea-Bissau)",
            GY: "Guyana",
            HT: "Haiti",
            HM: "Đảo Heard và Quần đảo Mcdonald (Heard Island and Mcdonald Islands)",
            VA: "Tòa thánh - Quốc gia thành phố Vatican (Holy See - Vatican City State)",
            HN: "Honduras",
            HK: "Hồng Kông (Hong Kong)",
            HU: "Hungary",
            IS: "Iceland",
            IN: "Ấn Độ (India)",
            ID: "Indonesia",
            IR: "Iran, Cộng hòa Hồi giáo (Iran, Islamic Republic)",
            IQ: "I-rắc (Iraq)",
            IE: "Ireland",
            IM: "Đảo Man (Isle of Man)",
            IL: "Israel",
            IT: "Ý (Italy)",
            JM: "Gia-mai-ca (Jamaica)",
            JP: "Nhật Bản (Japan)",
            JE: "Jersey",
            JO: "Jordan",
            KZ: "Ca-dắc-xtan (Kazakhstan)",
            KE: "Kê-ni-a (Kenya)",
            KI: "Kiribati",
            KP: "Hàn Quốc, Cộng hòa Dân chủ Nhân dân (Korea, Democratic People'S Republic)",
            KR: "Cộng hòa Hàn Quốc (Korea, Republic)",
            KW: "Cô-oét (Kuwait)",
            KG: "Kyrgyzstan",
            LA: "Cộng hòa Dân chủ nhân dân Lào (Lao People'S Democratic Republic)",
            LV: "Lát-vi-a (Latvia)",
            LB: "Liban (Lebanon)",
            LS: "Lesotho",
            LR: "Liberia",
            LY: "Libyan Arab Jamahiriya",
            LI: "Liechtenstein",
            LT: "Litva (Lithuania)",
            LU: "Lúc-xăm-bua (Luxembourg)",
            MO: "Macao",
            MK: "Macedonia, Cộng hòa Nam Tư cũ (Macedonia, The Former Yugoslav Republic)",
            MG: "Madagascar",
            MW: "Ma-lai-xi-a (Malawi)",
            MY: "Ma-lai-xi-a (Malaysia)",
            MV: "Ma-đi-vơ (Maldives)",
            ML: "Ma-li (Mali)",
            MT: "Malta",
            MH: "Đảo Marshall (Marshall Islands)",
            MQ: "Martinique",
            MR: "Mauritania",
            MU: "Mauritius",
            YT: "Mayotte",
            MX: "Mê hi cô (Mexico)",
            FM: "Liên bang Micronesia (Micronesia, Federated States)",
            MD: "Cộng hòa Moldova (Moldova Republic)",
            MC: "Monaco",
            MN: "Mông Cổ (Mongolia)",
            MS: "Montserrat",
            MA: "Ma-rốc (Morocco)",
            MZ: "Mozambique",
            MM: "Myanmar",
            NA: "Namibia",
            NR: "Nauru",
            NP: "Nê-pan (Nepal)",
            NL: "Hà Lan (Netherlands)",
            AN: "Antille thuộc Hà Lan (Netherlands Antilles)",
            NC: "Caledonia mới (New Caledonia)",
            NZ: "Tân Tây Lan (New Zealand)",
            NI: "Ni-ca-ra-goa (Nicaragua)",
            NE: "Ni-giê (Niger)",
            NG: "Ni-giê-ri-a (Nigeria)",
            NU: "Niue",
            NF: "Đảo Norfolk (Norfolk Island)",
            MP: "Quần đảo Bắc Mariana (Northern Mariana Islands)",
            NO: "Na Uy (Norway)",
            OM: "Ô-man (Oman)",
            PK: "Pa-ki-xtan (Pakistan)",
            PW: "Palau",
            PS: "Lãnh thổ Palestine, bị chiếm đóng (Palestinian Territory, Occupied)",
            PA: "Pa-na-ma (Panama)",
            PG: "Papua New Guinea",
            PY: "Paraguay",
            PE: "Pêru (Peru)",
            PH: "Phi líp pin (Philippines)",
            PN: "Cái hố (Pitcairn)",
            PL: "Ba Lan (Poland)",
            PT: "Bồ Đào Nha (Portugal)",
            PR: "Puerto Rico",
            QA: "Ca-ta (Qatar)",
            RE: "Đoàn tụ (Reunion)",
            RO: "Ru-ma-ni (Romania)",
            RU: "Liên Bang Nga (Russian Federation)",
            RW: "RWANDA",
            SH: "Thánh Helena (Saint Helena)",
            KN: "Saint Kitts và Nevis (Saint Kitts and Nevis)",
            LC: "Saint Lucia",
            PM: "Thánh Pierre và Miquelon (Saint Pierre and Miquelon)",
            VC: "Saint Vincent và Grenadines (Saint Vincent and the Grenadines)",
            WS: "Samoa",
            SM: "San Ma-ri-nô (San Marino)",
            ST: "Sao Tome và Principe (Sao Tome and Principe)",
            SA: "Ả Rập Saudi (Saudi Arabia)",
            SN: "Sénégal (Senegal)",
            CS: "Serbia và Montenegro (Serbia and Montenegro)",
            SC: "Seychelles",
            SL: "Sierra Leone",
            SG: "Singapore",
            SK: "Slovakia",
            SI: "Slovenia",
            SB: "Quần đảo Solomon (Solomon Islands)",
            SO: "Somali (Somalia)",
            ZA: "Nam Phi (South Africa)",
            GS: "Phía Nam Georgia và Phía nam quần đảo Sandwich (South Georgia and the South Sandwich Islands)",
            ES: "Tây ban nha (Spain)",
            LK: "Sri Lanka",
            SD: "Su-đăng (Sudan)",
            SR: "Suriname",
            SJ: "Svalbard and Jan Mayen",
            SZ: "Swaziland",
            SE: "Thụy Điển (Sweden)",
            CH: "Thụy sĩ (Switzerland)",
            SY: "Cộng Hòa Arab Syrian (Syrian Arab Republic)",
            TW: "Đài Loan, tỉnh Trung Quốc (Taiwan, Province of China)",
            TJ: "Tajikistan",
            TZ: "Cộng hòa Thống nhất Tanzania (Tanzania, United Republic)",
            TH: "Thái Lan (Thailand)",
            TL: "Đông Timor (Timor-Leste)",
            TG: "Togo",
            TK: "Tokelau",
            TO: "Tonga",
            TT: "Trinidad and Tobago",
            TN: "Tunisia",
            TR: "Thổ Nhĩ Kỳ (Turkey)",
            TM: "Tuốc-mê-ni-xtan (Turkmenistan)",
            TC: "Quần đảo Turks và Caicos (Turks and Caicos Islands)",
            TV: "Tuvalu",
            UG: "Uganda",
            UA: "Ukraine",
            AE: "Các Tiểu Vương Quốc Ả Rập Thống Nhất (United Arab Emirates)",
            GB: "Vương quốc Anh (United Kingdom)",
            US: "Hoa Kỳ (United States)",
            UM: "Quần đảo nhỏ xa xôi của Hoa Kỳ (United States Minor Outlying Islands)",
            UY: "U-ru-goay (Uruguay)",
            UZ: "U-dơ-bê-ki-xtan (Uzbekistan)",
            VU: "Vanuatu",
            VE: "Venezuela",
            VN: "Việt Nam (Viet Nam)",
            VG: "Quần đảo Virgin thuộc Anh (Virgin Islands, British)",
            VI: "Quần đảo Virgin, Hoa Kỳ (Virgin Islands, U.S)",
            WF: "Wallis and Futuna",
            EH: "Phía tây Sahara (Western Sahara)",
            YE: "Y-ê-men (Yemen)",
            ZM: "Zambia",
            ZW: "Zimbabuê (Zimbabwe)"
        },

        create: function(content, panels) {
            panels.forEach((x) => {
                let el = content.FindChildTraverse(x.id);
                if (typeof el !== "undefined" && el !== null) return;

                content.BCreateChildren(x.panel);
                x.scripts.forEach(y => y(content));
            });

            return true;
        },

        destroy: function(content, panels) {
            panels.forEach((x) => {
                let el = content.FindChildTraverse(x.id);
                if (typeof el === "undefined" || el === null) return;

                el.DeleteAsync(0.0);
            });

            return true;
        },

        register_events: function(event, func) {
            if (!ep_globals.handlers[event]) {
                ep_globals.handlers[event] = [];
            }

            ep_globals.handlers[event].push(func);
        },

        unregister_events: function() {
            for (const [key, value] of Object.entries(ep_globals.handlers)) {
                for (const v of value) {
                    $.UnregisterForUnhandledEvent(key, v);
                    ep_globals.handlers[key] = ep_globals.handlers[key].filter((x) => x != v);
                for (const [key, value] of Object.entries(ep_globals.elements)) {
                    value(); // destroy elements
                };
                }
            }
        },

        apply_styles: function(target, styles) {
            for (const [key, value] of Object.entries(styles)) {
                target.style[key] = value;
            }
        },

        open_ad: function() {
            SteamOverlayAPI.OpenExternalBrowserURL('aimware.net');
        },
    };

    var ep_time = (function()
    {
        const month_names = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];

        const get_formatted_date = function(date, preformatted = false, hide_year = false) {
            const day = date.getDate();
            const month = month_names[date.getMonth()];
            const year = date.getFullYear();
            const hours = date.getHours();
            let minutes = date.getMinutes();

            if (minutes < 10) {
                // Adding leading zero to minutes
                minutes = `0${ minutes }`;
            }

            if (preformatted) {
                // Today at 10:20
                // Yesterday at 10:20
                return `${ preformatted } at ${ hours }:${ minutes }`;
            }

            if (hide_year) {
                // 10. January at 10:20
                return `${ day }. ${ month } at ${ hours }:${ minutes }`;
            }

            // 10. January 2017. at 10:20
            return `${ day }. ${ month } ${ year } at ${ hours }:${ minutes }`;
        };

        const _ago = function(date) {
            if (!date) {
                return null;
            }

            const this_date = typeof date === 'object' ? date : new Date(date);
            const day_in_ms = 86400000; // 24 * 60 * 60 * 1000
            const today = new Date();
            const yesterday = new Date(today - day_in_ms);
            const seconds = Math.round((today - this_date) / 1000);
            const minutes = Math.round(seconds / 60);
            const is_today = today.toDateString() === date.toDateString();
            const is_yesterday = yesterday.toDateString() === date.toDateString();
            const is_this_year = today.getFullYear() === date.getFullYear();

            if (seconds < 5) {
                return 'now';
            } else if (seconds < 60) {
                return `${ seconds } seconds ago`;
            } else if (seconds < 90) {
                return 'about a minute ago';
            } else if (minutes < 60) {
                return `${ minutes } minutes ago`;
            } else if (is_today) {
                return get_formatted_date(this_date, 'Today'); // Today at 10:20
            } else if (is_yesterday) {
                return get_formatted_date(this_date, 'Yesterday'); // Yesterday at 10:20
            } else if (is_this_year) {
                return get_formatted_date(this_date, false, true); // 10. January at 10:20
            }

            return get_formatted_date(this_date); // 10. January 2017. at 10:20
        };

        return {
            ago: _ago
        };
    })();

    ep_steam_profile = function(profile) {
        let _ = profile;

        const persona = [
            'Offline',
            'Online',
            'Busy',
            'Away',
            'Snooze',
            'looking to trade',
            'looking to play'
        ];

        const visiblity = {
            1: 'Private',
            3: 'Public'
        };

        const _this = function() {
            return _;
        };

        const _id = function() {
            return _.steamid;
        };

        const _name = function(method) {
            switch (method) {
                case 'custom':
                    const matches = _url().match(/steamcommunity.com\/(id|profiles)\/(.*)[/]/i);
                    $.Msg(matches);
                    return matches[2];
                    break;

                default:
                    return _.personaname;
                    break;
            }
        };

        const _url = function(method) {
            switch (method) {
                case 'id':
                    return `https://steamcommunity.com/profiles/${_id()}`
                    break;

                default:
                    return _.profileurl;
                    break;
            }
        };

        const _avatar = function(method) {
            switch (method) {
                case 'small':
                    return _.avatar;
                    break;

                case 'medium':
                    return _.avatarmedium;
                    break;

                case 'hash':
                    return _.avatarhash;
                    break;

                default:
                    return _.avatarfull;
                    break;
            }
        };

        const _persona_state = function() {
            return persona[_.profilestate];
        };

        const _visibility_state = function() {
            return visibility[_.communityvisibilitystate];
        };

        // useless
        const _profile_state = function() {
            return typeof _.profilestate === 'undefined' ? 0 : 1;
        };

        const _last_online = function() {
            return ep_time.ago(new Date(_.lastlogoff * 1000));
        };

        const _comment_state = function() {
            return typeof _.commentpermission === 'undefined' ? 0 : 1;
        };

        const _created = function() {
            return typeof _.timecreated === 'undefined' ? false : ep_time.ago(new Date(_.timecreated * 1000));
        };

        const _primary_clanid = function() {
            return typeof _.primaryclanid === 'undefined' ? false : _.primaryclanid;
        };

        return {
            _: _this,
            id: _id,
            name: _name,
            url: _url,
            avatar: _avatar,
            persona_state: _persona_state,
            visibility_state: _visibility_state,
            profile_state: _profile_state,
            last_online: _last_online,
            comment_state: _comment_state,
            created: _created,
            primary_clanid: _primary_clanid
        };
    };

    var ep_nearby_helper = (function()
    {
        const content = $.GetContextPanel().FindChildTraverse("JsFriendsList-lobbies").FindChildTraverse("JsFriendsListSettings").GetChild(0);
        const panels = [
            {
                "id": "nearby_helper_invite_btn",
                "panel": `
                    <Button id="nearby_helper_invite_btn"
                        class="IconButton"
                        onmouseover="UiToolkitAPI.ShowTextTooltip( 'nearby_helper_invite_btn', 'Invite Nearby' );"
                        onmouseout="UiToolkitAPI.HideTextTooltip();">
                        <Image src="file://{images}/icons/ui/invite.svg" />
                    </Button>
                `,
                "scripts": [
                    (content) => {
                        content.FindChildTraverse("nearby_helper_invite_btn").SetPanelEvent('onactivate', ep_nearby_helper.invite)
                    },
                    (content) => { 
                        content.MoveChildBefore(content.FindChildTraverse("nearby_helper_invite_btn"), content.FindChildTraverse("JsFriendsList-lobbies-toolbar-button-refresh"));
                    }
                ]
            }
        ];

        const _init = function() {
            if (!content.BHasClass("left-right-flow")) content.AddClass("left-right-flow");

            ep_globals.destroy(content, panels);
            ep_globals.create(content, panels);

            ep_globals.elements.nearby_helper = () => { ep_globals.destroy(content, panels); };
        };

        const _invite = function() {
            const nearby_count = PartyBrowserAPI.GetResultsCount();

            if (nearby_count.length <= 0) return false;

            for (let i = 0; i < nearby_count; i++) {
                StoreAPI.RecordUIEvent("ActionInviteFriendFrom_nearby");
                const xuid = PartyBrowserAPI.GetXuidByIndex(i);
                FriendsListAPI.ActionInviteFriend(xuid, '');
                $.DispatchEvent('FriendInvitedFromContextMenu', xuid);
            }

            return true;
        };

        return {
            init: _init,
            invite: _invite
        };
    })();

    var ep_match_helper = (function()
    {
        let content = null
        const panels = [
            {
                "id": "match_helper_panel",
                "panel": `
                    <Panel id="match_helper_panel"
                        class="horizontal-align-right left-right-flow">
                        <Button id="match_helper_leave_btn"
                            class="IconButton horizontal-align-right">
                            onmouseover="UiToolkitAPI.ShowTextTooltip( 'match_helper_leave_btn', 'Leave Lobby' );"
                            onmouseout="UiToolkitAPI.HideTextTooltip();">
                            <Image src="file://{images}/icons/ui/leave.svg" />
                        </Button>

                        <Button id="match_helper_cancel_btn"
                            class="IconButton horizontal-align-right">
                            onmouseover="UiToolkitAPI.ShowTextTooltip( 'match_helper_cancel_btn', 'Cancel Queue' );"
                            onmouseout="UiToolkitAPI.HideTextTooltip();">
                            <Image src="file://{images}/icons/ui/cancel.svg" />
                        </Button>
                    </Panel>
                `,
                "scripts": [
                    (content) => { 
                        content.FindChildTraverse("match_helper_leave_btn").SetPanelEvent('onactivate', () => { LobbyAPI.CloseSession(); })
                    },
                    (content) => {
                        content.FindChildTraverse("match_helper_cancel_btn").SetPanelEvent('onactivate', () => { LobbyAPI.StopMatchmaking(); })
                    }
                ]
            }
        ];

        const _init = function(popup) {
            content = popup.FindChildrenWithClassTraverse("accept-match__bg")[0];
            ep_globals.destroy(content, panels);
            ep_globals.create(content, panels);
        };

        return {
            init: _init
        }
    })(); 
    
    var ep_lobby_commands = (function()
    {
        const _utils = {
            party: function(msg) {
                let filter_msg = msg.split(' ').join('\u{00A0}');
                PartyListAPI.SessionCommand('Game::Chat', `run all xuid ${MyPersonaAPI.GetXuid()} chat ${filter_msg}`);
            },

            success: function(msg) {
                let prefix = `${ep_globals.symbols.check} ${ep_globals.symbols.bullet} ${msg}`
                let filter_msg = prefix.split(' ').join('\u{00A0}');
                PartyListAPI.SessionCommand('Game::Chat', `run all xuid ${MyPersonaAPI.GetXuid()} chat ${filter_msg}`);
            },

            error: function(msg) {
                let prefix = `${ep_globals.symbols.times} ${ep_globals.symbols.bullet} ${msg}`
                let filter_msg = prefix.split(' ').join('\u{00A0}');
                PartyListAPI.SessionCommand('Game::Chat', `run all xuid ${MyPersonaAPI.GetXuid()} chat ${filter_msg}`);
            },

            warn: function(msg) {
                let prefix = `${ep_globals.symbols.warning} ${ep_globals.symbols.bullet} ${msg}`
                let filter_msg = prefix.split(' ').join('\u{00A0}');
                PartyListAPI.SessionCommand('Game::Chat', `run all xuid ${MyPersonaAPI.GetXuid()} chat ${filter_msg}`);
            },

            get_lobby_users: function(steam_id = "") {
                let settings = LobbyAPI.GetSessionSettings().members;
                if (!settings) return false;

                let players = Array.from({length: settings.numMachines}, (item, i) => {
                    return {
                        name: settings[`machine${i}`].player0.name,
                        xuid: settings[`machine${i}`].player0.xuid,
                        location: settings[`machine${i}`].player0.game.loc
                    }
                });

                let output = []

                if (ep_globals.regex.steamid64.test(steam_id)) {
                    const p = players.find((x) => x.xuid === steam_id);
                    if (p) output.push(p);
                } else if (ep_globals.regex.lobby_index.test(steam_id)) {
                    const p = players[Number(steam_id) - 1]
                    if (p) output.push(p);
                } else if (ep_globals.regex.friend_code.test(steam_id)) {
                    players.every((x) => {
                        if (x.xuid === FriendsListAPI.GetXuidFromFriendCode(steam_id)) output.push(x);
                        return true;
                    });
                } else if (steam_id.length > 0) {
                    players.every((x) => {
                        if (x.name.toLowerCase().startsWith(steam_id.toLowerCase())) output.push(x);
                        return true;
                    });
                } else {
                    output = players;
                }

                return output;
            },

            startq: function() {
                let stage = '';

                //let tournament = $.GetContextPanel().FindChildTraverse('TournamentStageDropdown');
                //if (tournament.GetSelected() !== null) stage = tournament.GetSelected().GetAttributeString('data', '');

                LobbyAPI.StartMatchmaking(
                    MyPersonaAPI.GetMyOfficialTournamentName(),
                    MyPersonaAPI.GetMyOfficialTeamName(),
                    '',
                    stage
                );
            },

            stopq: function() {
                LobbyAPI.StopMatchmaking();
            }
        };

        let _commands = [
            {
                title: 'Help',
                cmds: ['help', 'h'],
                enabled: true,
                exec: (cmd, args, user, steam_id) => {
                    _commands.forEach((x, i) => {
                        if (i == 0) return;

                        let msg = '';

                        // enabled?
                        msg += `${x.enabled ? ep_globals.symbols.check : ep_globals.symbols.times} `;
                        // command
                        msg += `${x.title} ${ep_globals.symbols.bullet} (`;
                        // cmds & alias
                        let cmds = x.cmds.map((y) => `${ep_globals.config.prefix}${y}`);
                        msg += `${cmds.join(', ')})`;
                        
                        _utils.party(msg);
                    });
                }
            },
            {
                title: 'Bắt đầu tìm trận',
                cmds: ['startq', 'start', 'q'],
                enabled: true,
                exec: (cmd, args, user, steam_id) => {
                    if (!LobbyAPI.BIsHost()) return;

                    _utils.startq();
                }
            },
            {
                title: 'Dừng Tìm Trận',
                cmds: ['stopq', 'stop', 'sq'],
                enabled: true,
                exec: (cmd, args, user, steam_id) => {
                    _utils.stopq();
                }
            },
            {
                title: 'Khởi động lại tìm trận',
                cmds: ['restartq', 'restart', 'rq'],
                enabled: true,
                exec: (cmd, args, user, steam_id) => {
                    if (!LobbyAPI.BIsHost()) return;

                    _utils.stopq();

                    $.Schedule(1, () => {
                        _utils.startq();
                    });
                }
            },
            {
                title: 'Pick Maps',
                cmds: ['maps', 'map', 'm'],
                enabled: true,
                exec: (cmd, args, user, steam_id) => {
                    if (!LobbyAPI.BIsHost()) return;

                    let settings = LobbyAPI.GetSessionSettings();
                    let config = GameTypesAPI.GetConfig();
                    if (!settings || !config) {
                        _utils.error('Something went wrong!');
                        return;
                    }

                    if (args.length === 0) {
                        _utils.error('Please provide at least one argument!');
                        return;
                    }

                    let new_settings = {
                        update: {
                            game: {
                                mapgroupname: []
                            }
                        }
                    };

                    let map_pool = Object.keys(config.gameTypes[settings.game.type].gameModes[settings.game.mode].mapgroupsMP);

                    let converted_names = {}
                    for (const map of map_pool) {
                        converted_names[map] = $.Localize(`#SFUI_Map${map.replace('mg', '')}`);
                    }

                    for (const map of args) {
                        const map_regex = new RegExp(map, 'i');
                        Object.entries(converted_names).find((x) => {
                            if (map_regex.test(x[1])) {
                                new_settings.update.game.mapgroupname.push(x[0])
                                return true;
                            }
                            
                            return false;
                        });
                    }

                    if (new_settings.update.game.mapgroupname.length === 0) {
                        _utils.error(`Không tìm thấy maps!`);
                    } else {
                        const friendly_maps = new_settings.update.game.mapgroupname.map((x) => converted_names[x])

                        _utils.success(`Đổi maps sang:`);

                        let chunk = 0
                        for (var i = 0; i < Math.ceil(friendly_maps.length / 4); i++) {
                            _utils.party(friendly_maps.slice(chunk, chunk + 4).join(', '));
                            chunk += 4;
                        }

                        new_settings.update.game.mapgroupname = new_settings.update.game.mapgroupname.join(',');
                        LobbyAPI.UpdateSessionSettings(new_settings);
                    }
                }
            },
            {
                title: 'Chế độ',
                cmds: ['gamemode', 'mode', 'gm'],
                enabled: true,
                exec: (cmd, args, user, steam_id) => {
                    if (!LobbyAPI.BIsHost()) return;

                    let settings = LobbyAPI.GetSessionSettings();
                    if (!settings) {
                        _utils.error('Something went wrong!');
                        return;
                    }

                    let new_settings = {
                        update: {
                            game: {}
                        }
                    };

                    if (ep_globals.regex.competitive.test(args[0])) {
                        new_settings.update.game.mode = 'competitive';
                    } else if (ep_globals.regex.wingman.test(args[0])) {
                        new_settings.update.game.mode = 'scrimcomp2v2';
                    } else {
                        if (settings.game.mode == 'competitive') {
                            new_settings.update.game.mode = 'scrimcomp2v2';
                        } else {
                            new_settings.update.game.mode = 'competitive';
                        }
                    }
                    new_settings.update.game.type = 'classic';

                    LobbyAPI.UpdateSessionSettings(new_settings);

                    _utils.success(`Changed Gamemode to ${new_settings.update.game.mode}!`);
                }
            },
            {
                title: 'Check vị trí',
                cmds: ['locate', 'loc'],
                enabled: true,
                exec: (cmd, args, user, steam_id) => {
                    const users = args.length !== 0 ? _utils.get_lobby_users(args[0]) : _utils.get_lobby_users()

                    if (users.length <= 0) {
                        _utils.error('Nothing found!');
                        return;
                    }

                    users.forEach((x) => {
                        _utils.party(`${ep_globals.symbols.location} ${ep_globals.symbols.bullet} ${x.name} đến từ ${ep_globals.locations[x.location]}`);
                    });
                }
            }
        ];

        const _toggle_command = function(type, value) {
            _commands.every((c, i) => {
                if (c.title == type) {
                    _commands[i].enabled = value;
                    return false;
                }

                return true;
            });
        }

        const _on_new_chat_entry = function(panel, type) {
            switch (type) {
                case 'PlayerChat':
                    $.Schedule(0.2, function(panel)
                    {
                        let chat_lines = panel.GetParent().Children();
                        let line = chat_lines[0].GetChild(0);
                        if (!line || !line.BHasClass('left-right-flow') || !line.BHasClass('horizontal-align-left')) return;

                        let label = line.GetChild(line.GetChildCount() - 1);
                        if (!label || !label.text) return;

                        let user = $.Localize('{s:player_name}', label);
                        let msg = $.Localize('{s:msg}', label);
                        if (!user || !msg) return;

                        if (!msg.startsWith(ep_globals.config.prefix)) return;

                        let steam_id = line.GetChildCount() == 2 ? line.Children()[0].steamid : null;

                        const args = msg.slice(ep_globals.config.prefix.length).trim().split(' ');
                        const command = args.shift().toLowerCase();
                        _commands.every((c) => {
                            let f = false;

                            if (!c.enabled) return true;

                            c.cmds.every((a) => {
                                if (a === command) {
                                    c.exec(command, args, user, steam_id);
                                    return false;
                                }
                                return true;
                            });
                            return f ? false : true;
                        });

                    }.bind(this, panel));
                    break;
            }
        };

        return {
            toggle_command: _toggle_command,
            on_new_chat_entry: _on_new_chat_entry
        };
    })();

    var ep_invite_helper = (function()
    {
        const content = $.GetContextPanel().FindChildTraverse("JsFriendsList-requests").FindChildTraverse("JsFriendsListSettings").GetChild(0);
        const panels = [
            {
                "id": "invite_helper_copy_btn",
                "panel": `
                    <Button id="invite_helper_copy_btn"
                        class="IconButton"
                        onmouseover="UiToolkitAPI.ShowTextTooltip( 'invite_helper_copy_btn', 'Copy Friendcode' );"
                        onmouseout="UiToolkitAPI.HideTextTooltip();">
                        <Image src="file://{images}/icons/ui/link.svg" />
                    </Button>
                `,
                "scripts": [
                    () => { content.FindChildTraverse("invite_helper_copy_btn").SetPanelEvent('onactivate', ep_invite_helper.copy_code) }
                ]
            },
            {
                "id": "start_q_button",
                "panel": `
                    <Button id="start_q_button"
                        class="IconButton"
                        onmouseover="UiToolkitAPI.ShowTextTooltip( 'start_q_button', 'Start Match' );"
                        onmouseout="UiToolkitAPI.HideTextTooltip();">
                        <Image src="file://{images}/icons/ui/play.svg" />
                    </Button>
                `,
                "scripts": [
                    () => { content.FindChildTraverse("start_q_button").SetPanelEvent('onactivate', ep_invite_helper.startqb) }
                ]
            },
            {
                "id": "stop_q_button",
                "panel": `
                    <Button id="stop_q_button"
                        class="IconButton"
                        onmouseover="UiToolkitAPI.ShowTextTooltip( 'stop_q_button', 'Stop Match' );"
                        onmouseout="UiToolkitAPI.HideTextTooltip();">
                        <Image src="file://{images}/icons/ui/exit.svg" />
                    </Button>
                `,
                "scripts": [
                    () => { content.FindChildTraverse("stop_q_button").SetPanelEvent('onactivate', ep_invite_helper.stopqb) }
                ]
            },
            {
                "id": "restart_q_button",
                "panel": `
                    <Button id="restart_q_button"
                        class="IconButton"
                        onmouseover="UiToolkitAPI.ShowTextTooltip( 'restart_q_button', 'Restart Match' );"
                        onmouseout="UiToolkitAPI.HideTextTooltip();">
                        <Image src="file://{images}/icons/ui/refresh.svg" />
                    </Button>
                `,
                "scripts": [
                    () => { content.FindChildTraverse("restart_q_button").SetPanelEvent('onactivate', ep_invite_helper.restartqb) }
                ]
            },
            {
                "id": "invite_helper_location_btn",
                "panel": `
                    <Button id="invite_helper_location_btn"
                        class="IconButton"
                        onmouseover="UiToolkitAPI.ShowTextTooltip( 'invite_helper_location_btn', 'Check Location' );"
                        onmouseout="UiToolkitAPI.HideTextTooltip();">
                        <Image src="file://{images}/icons/ui/inposition.svg" />
                    </Button>
                `,
                "scripts": [
                    (content) => {
                        content.FindChildTraverse("invite_helper_location_btn").SetPanelEvent('onactivate', ep_invite_helper.location)
                    }
                ]
            }
        ];

        const _init = function() {
            if (!content.BHasClass("left-right-flow")) content.AddClass("left-right-flow");

            ep_globals.destroy(content, panels);
            ep_globals.create(content, panels);

            ep_globals.elements.invite_helper = () => { ep_globals.destroy(content, panels); };
        };

        const _copy_code = function() {
            SteamOverlayAPI.CopyTextToClipboard(MyPersonaAPI.GetFriendCode());
        };

        const _startqb = function() {
            LobbyAPI.StartMatchmaking('', '', '', '');
        };

        const _stopqb = function() {
            LobbyAPI.StopMatchmaking();
        };

        const _restartqb = function() {
            if (!LobbyAPI.BIsHost()) return;

            LobbyAPI.StopMatchmaking();

            $.Schedule(1, () => {
                LobbyAPI.StartMatchmaking('', '', '', '');
            });
        };

        const _invite = function(code) {
            if (code === null) return false;

            StoreAPI.RecordUIEvent("ActionInviteFriendFrom_nearby");
            const xuid = FriendsListAPI.GetXuidFromFriendCode(code.toUpperCase());
            FriendsListAPI.ActionInviteFriend(xuid, '');
            $.DispatchEvent('FriendInvitedFromContextMenu', xuid);

            return true;
        };

        const _create_lobby = function() {
            LobbyAPI.CreateSession();
            PartyListAPI.SessionCommand("MakeOnline", "");

            return true;
        };

        const _location = function() {
            let settings = LobbyAPI.GetSessionSettings().members;
            if (!settings) {
                return false;
            }

            let players = Array.from({length: settings.numMachines}, (item, i) => {
                return {
                    name: settings[`machine${i}`].player0.name,
                    location: settings[`machine${i}`].player0.game.loc
                }
            });

            players.forEach((x) => {
                let title = `${ep_globals.symbols.location} ${ep_globals.symbols.bullet} ${x.name} is from ${ep_globals.locations[x.location]}`;
                let message = title.split(' ').join('\u{00A0}');
                let xuid = MyPersonaAPI.GetXuid();
                if (!xuid) return false;
                PartyListAPI.SessionCommand('Game::Chat', `run all xuid ${xuid} chat ${message}`);
            });

            return true
        };

        return {
            init: _init,
            copy_code: _copy_code,
            startqb: _startqb,
            stopqb: _stopqb,
            restartqb: _restartqb,
            invite: _invite,
            create_lobby: _create_lobby,
            location: _location,
        };
    })();    

    var ep_ad_helper = (function()
    {
        const content = $.GetContextPanel().FindChildrenWithClassTraverse('chat-panel-outer')[0];
        const panels = [
            {
                "id": "ad_helper_main_pn",
                "panel": `
                    <Panel id="ad_helper_main_pn">
                        <Panel id="ad_helper_main_pn_blur" style="opacity: 0;" />
                        <Panel id="ad_helper_main_pn_inner" style="opacity: 0;">
                            <Panel id="ad_helper_main_pn_header">
                                <Image src="file://{images}/icons/ui/buyzone.svg" texturewidth="24" textureheight="-1" />
                                <Label text="Get premium version here!" />
                                <Image src="file://{images}/icons/ui/link.svg" texturewidth="16" textureheight="-1" />
                                <Image src="file://{images}/icons/ui/exit.svg" texturewidth="16" textureheight="-1" />
                            </Panel>
                        </Panel>
                    </Panel>
                `,
                "scripts": [
                    (content) => {
                        const main = 'ad_helper_main_pn';

                        let panel = {};
                        panel._ = content.FindChildTraverse(main);
                        panel.blur = panel._.FindChildTraverse(`${main}_blur`);
                        panel.inner = panel._.FindChildTraverse(`${main}_inner`);

                        ep_globals.apply_styles(panel._, {
                            width: '100%',
                            height: '60px',
                            paddingBottom: '26px',
                        });

                        $.GetContextPanel().FindChildTraverse('MainMenuCore').AddBlurPanel(panel.blur);

                        ep_globals.apply_styles(panel.blur, {
                            width: '100%',
                            height: '100%',
                            opacity: '0.1',
                            backgroundColor: 'rgba(128, 0, 255, 0.55)',
                            transitionProperty: 'background-color',
                            transitionDuration: '0.2s',
                            transitionTimingFunction: 'ease-in-out'
                        });

                        panel._.SetPanelEvent('onactivate', ep_globals.open_ad);

                        ep_globals.apply_styles(panel.inner, {
                            width: '100%',
                            height: '100%',
                            padding: '5px 10px',
                            transitionProperty: 'opacity',
                            transitionDuration: '1s',
                            transitionTimingFunction: 'ease-in-out'
                        });
                        
                        let header = {};
                        header._ = panel._.FindChildTraverse(`${main}_header`);
                        ep_globals.apply_styles(header._, {
                            width: '100%',
                            flowChildren: 'right',
                        });

                        header.icon = header._.GetChild(0);
                        ep_globals.apply_styles(header.icon, {
                            paddingRight: "10px",
                            verticalAlign: 'center'
                        });

                        header.label = header._.GetChild(1);
                        ep_globals.apply_styles(header.label, {
                            fontSize: '18px'
                        });
                        
                        header.link = header._.GetChild(2);
                        ep_globals.apply_styles(header.link, {
                            verticalAlign: 'center',
                            opacity: 0,
                            transitionProperty: 'opacity',
                            transitionDuration: '0.2s',
                            transitionTimingFunction: 'ease-in-out'
                        });

                        panel._.SetPanelEvent('onmouseover', () => {
                            ep_globals.apply_styles(panel.blur, {
                                backgroundColor: 'rgba(128, 0, 255, 1)'
                            });

                            ep_globals.apply_styles(header.link, {
                                opacity: 1
                            });

                            ep_globals.apply_styles(header.close, {
                                opacity: 0.55
                            });
                        });
                        
                        panel._.SetPanelEvent('onmouseout', () => {
                            ep_globals.apply_styles(panel.blur, {
                                backgroundColor: 'rgba(128, 0, 255, 0.55)'
                            });

                            ep_globals.apply_styles(header.link, {
                                opacity: 0
                            });

                            ep_globals.apply_styles(header.close, {
                                opacity: 0
                            });
                        });

                        header.close = header._.GetChild(3);
                        ep_globals.apply_styles(header.close, {
                            verticalAlign: 'center',
                            horizontalAlign: 'right',
                            opacity: 0,
                            transitionProperty: 'opacity',
                            transitionDuration: '0.2s',
                            transitionTimingFunction: 'ease-in-out'
                        });

                        header.close.SetPanelEvent('onactivate', () => {
                            ep_globals.destroy(content, [{ id: main }]);
                            content.GetChild(0).style.paddingTop = "0px";
                        });

                        header.close.SetPanelEvent('onmouseover', () => {
                            ep_globals.apply_styles(header.close, {
                                opacity: 1
                            });
                        });

                        header.close.SetPanelEvent('onmouseout', () => {
                            ep_globals.apply_styles(header.close, {
                                opacity: 0.55
                            });
                        });


                        content.GetChild(0).style.paddingTop = "34px";
                        ep_globals.apply_styles(panel.blur, {
                            opacity: 1
                        });

                        ep_globals.apply_styles(panel.inner, {
                            opacity: 1
                        });
                    }
                ]
            }
        ];

        const _init = function() {
            ep_globals.destroy(content, panels);
            ep_globals.create(content, panels);

            ep_globals.elements.ad_helper = () => { 
                ep_globals.destroy(content, panels);

                if (!ep_globals.config.premium)
                    $.GetContextPanel().FindChildrenWithClassTraverse('chat-panel-outer')[0].GetChild(0).style.paddingTop = "0px";
            };
        };

        return {
            init: _init,
        };

    })();

    ep_nearby_helper.init();
    ep_invite_helper.init();

    if (ep_globals.config.premium) 
        ep_globals.register_events("OnNewChatEntry", $.RegisterForUnhandledEvent("OnNewChatEntry", ep_lobby_commands.on_new_chat_entry));
        ep_globals.register_events("ShowAcceptPopup", $.RegisterForUnhandledEvent("ShowAcceptPopup", ep_match_helper.init));
        
    if (!ep_globals.config.premium) 
        ep_ad_helper.init();
]]);

callbacks.Register("Unload", function()
    panorama.RunScript("ep_globals.unregister_events()")
end)
--[[Panorama Util End]]--

--[[Clantag Changer]]--
local Clantag = {
    reverse = " ‮",
    tag = {},
    ffi = {
        _SetClantag = ffi.cast('int(__fastcall*)(const char*, const char*)', mem.GetModuleBase('engine.dll') + 0x8DA80),
        _LastTag = "",
        SetClantag = function(self, tag)
            if tag == self._LastTag then return end
            self._SetClantag(tag, tag)
            self._LastTag = tag
        end
    },
    CreateTag = function(self, tag)
        local val = Menu.Mode:GetValue()
        if val == 0 then
            self:StaticTag(tag)
        elseif val == 1 then
            self:RotateTag(tag)
        elseif val == 2 then
            self:MarqueeTag(tag)
        elseif val == 3 then
            self:ArabicTag(tag)
        end
    end,
    ArabicTag = function(self, tag)
        local out = {}
        table.insert(out, self.reverse .. tag:reverse())
        for i = 1, #tag do
            table.insert(out, tag:sub(1, i) .. self.reverse .. tag:sub(i+1, #tag):reverse())
        end
    
        for i = #out - 1, 1, -1 do
            table.insert(out, out[i])
        end
        self.tag = out
    end,
    MarqueeTag = function(self, tag)
        local tbl = {}
        local out = {}
        tag:gsub(".", function(t) table.insert(tbl, t)end)
        
        for i = 1, #tbl do
            local str = ""
            str = str .. table.concat(tbl, "", i)
            for j = 1, i do str = " " .. str end
            table.insert(out, str)
        end
        table.insert(out, "")
        for i = 1, #tbl do
            local str = ""
            str = str .. table.concat(tbl, "", 1, i)
            for j = 1, i do str = str .. " " end
            table.insert(out, str)
        end
        self.tag = out
    end,
    StaticTag = function(self, tag)
        self.tag = {tag}
    end,
    RotateTag = function(self, tag)
        local curTag = tag
        local out = {tag}
        for i = 1, #tag do
            curTag = curTag:sub(#curTag) .. curTag:sub(1, -2)
            table.insert(out, curTag)
        end
        self.tag = out
    end,
    DrawHook = function(self)
        if not Menu.Enable:GetValue() then if self.ffi._LastTag ~= "" then self.ffi:SetClantag("") end return end
        if not entities.GetLocalPlayer() then return end

        local index = math.floor(math.fmod(globals.TickCount() / 32, #self.tag + 1) + 1)

        if self.tag[index] == nil then return end

        self.ffi:SetClantag(self.tag[index])
    end,
    UnloadHook = function(self)
        if self.ffi._LastTag ~= "" then self.ffi:SetClantag("") end
    end
}

gui.Button(left_tab3, "Set Clantag", function() Clantag:CreateTag(Menu.Text:GetValue()) end)

callbacks.Register("Draw", function()
    Clantag:DrawHook()
end)

callbacks.Register("Unload", function()
    Clantag:UnloadHook()
end)
--[[Clantag Changer End]]--

--[[BlockBot]]--
-- * Useful functions
local function round(n, d)
    local p = 10^d
    return math.floor(n*p)/p
end

local function cap(x, min, max)
    if x < min then
        return min
    elseif x > max then
        return max
    end

    return x
end

-- Blockbot groupbox
BlockbotEnable = gui.Checkbox(right_tab3, "blockboit.enable", "Enable", true)
BlockbotExtrapolation = gui.Checkbox(right_tab3, "blockbot.lerp", "Extrapolation", true)
BlockbotKey = gui.Keybox(right_tab3, "blockbot.key", "Key", 0)
BlockbotRetreatBhop = gui.Checkbox(right_tab3, "blockbot.retreat", "Retreat on Bhop", 0)
BlockbotRetreatSpeed = gui.Slider(right_tab3, "blockbot.retreat.speed", "Retreat Speed", 285.0, 50.0, 300.0)

-- * Blockbot
local BlockbotIconFont = draw.CreateFont("Veranda", 64, 64)
local BlockbotTextFont = draw.CreateFont("Veranda", 32, 64)
local BlockbotTarget = nil
local BlockbotCrouchBlock = false
local BlockbotLocalPlayer = nil

local function BlockbotOnFrameMain()
    if BlockbotEnable:GetValue() == false then
        return
    end
    
    BlockbotLocalPlayer = entities.GetLocalPlayer()
    if BlockbotLocalPlayer == nil or engine.GetServerIP() == nil then
        return
    end

    if (BlockbotKey:GetValue() == nil or BlockbotKey:GetValue() == 0) or not BlockbotLocalPlayer:IsAlive() then
        return
    end

    if input.IsButtonDown(BlockbotKey:GetValue()) and BlockbotTarget == nil then
        for Index, Entity in pairs(entities.FindByClass("CCSPlayer")) do
            if Entity:GetIndex() ~= BlockbotLocalPlayer:GetIndex() and Entity:IsAlive() then
                if BlockbotTarget == nil then
                    BlockbotTarget = Entity;
                elseif (BlockbotLocalPlayer:GetAbsOrigin() - BlockbotTarget:GetAbsOrigin()):Length() > (BlockbotLocalPlayer:GetAbsOrigin() - Entity:GetAbsOrigin()):Length() then
                    BlockbotTarget = Entity;
                end
            end
        end
    elseif not input.IsButtonDown(BlockbotKey:GetValue()) or not BlockbotTarget:IsAlive() then
        BlockbotTarget = nil
    end

    if BlockbotTarget ~= nil then
        local TargetPos = BlockbotTarget:GetBonePosition(5)
        local PosX, PosY = client.WorldToScreen(TargetPos)
        if PosX ~= nil and PosY ~= nil then
            -- Indicator
            if BlockbotTarget:GetHitboxPosition(0).z < BlockbotLocalPlayer:GetAbsOrigin().z and vector.Distance({BlockbotLocalPlayer:GetAbsOrigin()}, {BlockbotTarget:GetAbsOrigin()}) < 100 then
                BlockbotCrouchBlock = true
                draw.Color(255, 255, 0, 255)    
            else
                BlockbotCrouchBlock = false
                draw.Color(255, 0, 0, 255)
            end
            draw.SetFont(BlockbotIconFont)
            local IconSizeW, IconSizeH = draw.GetTextSize("+")
            draw.TextShadow(PosX - IconSizeW / 2, PosY, "+")
            
            -- Distance
            local Diff = BlockbotLocalPlayer:GetAbsOrigin() - BlockbotTarget:GetAbsOrigin()
            local Distance = tostring(round(Diff:Length(), 0))
            draw.Color(64, 255, 64, 255)
            draw.SetFont(BlockbotTextFont)
            local DistanceSizeW, DistanceSizeH = draw.GetTextSize(Distance)
            draw.TextShadow(PosX - DistanceSizeW / 2, PosY + IconSizeH*5/4, Distance)
            
            -- Velocity
            local TargetSpeed = vector.Length(BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[0]"), BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[1]"), BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[2]"))
            draw.Color(64, 64, 255, 255)
            if TargetSpeed > BlockbotRetreatSpeed:GetValue() and BlockbotRetreatBhop:GetValue() then
                draw.Color(255, 255, 64, 255)
            end
            local SpeedStr = tostring(round(TargetSpeed, 0))
            local SpeedSizeW, SpeedSizeH = draw.GetTextSize(SpeedStr)
            draw.TextShadow(PosX - SpeedSizeW / 2, PosY - IconSizeH*2/4, SpeedStr)
        end
    end
end

local targetAccel
local localAccel
local lastTargetSpeed = Vector3(0,0,0)
local lastLocalSpeed = Vector3(0,0,0)
local function BlockbotOnCreateMoveMain(UserCmd)
    if BlockbotEnable:GetValue() == false then
        return
    end
    if BlockbotTarget ~= nil then
	targetAccel = Vector3(BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[0]"), BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[1]"), BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[2]"))
	targetAccel = (targetAccel - lastTargetSpeed) * globals.TickInterval()
	local lastTargetSpeed = Vector3(BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[0]"), BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[1]"), BlockbotTarget:GetPropFloat("localdata", "m_vecVelocity[2]"))
        local TargetSpeed = lastTargetSpeed:Length()

	localAccel = Vector3(BlockbotLocalPlayer:GetPropFloat("localdata", "m_vecVelocity[0]"), BlockbotLocalPlayer:GetPropFloat("localdata", "m_vecVelocity[1]"), BlockbotLocalPlayer:GetPropFloat("localdata", "m_vecVelocity[2]"))
	localAccel = (localAccel - lastLocalSpeed) * globals.TickInterval()
	local lastLocalSpeed = Vector3(BlockbotLocalPlayer:GetPropFloat("localdata", "m_vecVelocity[0]"), BlockbotLocalPlayer:GetPropFloat("localdata", "m_vecVelocity[1]"), BlockbotLocalPlayer:GetPropFloat("localdata", "m_vecVelocity[2]"))

        local LocalAngles = UserCmd:GetViewAngles()
	local VecForward
	if BlockbotExtrapolation:GetValue() == true then
       	    VecForward = BlockbotTarget:GetAbsOrigin() + lastTargetSpeed * globals.TickInterval() + targetAccel * globals.TickInterval()*globals.TickInterval() / 2 - BlockbotLocalPlayer:GetAbsOrigin() + lastLocalSpeed * globals.TickInterval() + localAccel * globals.TickInterval()*globals.TickInterval() / 2
	else
            VecForward = BlockbotTarget:GetAbsOrigin() - BlockbotLocalPlayer:GetAbsOrigin()
	end
        local AimAngles = VecForward:Angles()
        
        if BlockbotCrouchBlock == true then
            UserCmd.forwardmove = cap( ((math.sin(math.rad(LocalAngles.y) ) *  VecForward.y) + (math.cos(math.rad(LocalAngles.y) ) * VecForward.x)) * 450, -450, 450)
            UserCmd.sidemove    = cap( ((math.cos(math.rad(LocalAngles.y) ) * -VecForward.y) + (math.sin(math.rad(LocalAngles.y) ) * VecForward.x)) * 450, -450, 450)
        else
            local DiffYaw = AimAngles.y - LocalAngles.y
            if DiffYaw > 180 then
                DiffYaw = DiffYaw - 360
            elseif DiffYaw < -180 then
                DiffYaw = DiffYaw + 360
            end
            if TargetSpeed > BlockbotRetreatSpeed:GetValue() and BlockbotRetreatBhop:GetValue() then
                UserCmd.forwardmove = -math.abs(TargetSpeed)
            end
            if DiffYaw > 0.25 then
                UserCmd.sidemove = -450
            elseif DiffYaw < -0.25 then
                UserCmd.sidemove = 450
            end
        end
    end
end

callbacks.Register("Draw", BlockbotOnFrameMain)
callbacks.Register("CreateMove", BlockbotOnCreateMoveMain)
--[[BlockBot End]]--

--[[Fast Bhop Dangerzone]]--
callbacks.Register("Draw", function()
    f = (ui.danger.fasthop:GetValue() ~= nil and ui.danger.fasthop:GetValue() ~= 0 and input.IsButtonPressed(ui.danger.fasthop:GetValue())) and 0 or f;
end);
callbacks.Register("CreateMove", function(ucmd)
    if ui.danger.fasthop:GetValue() ~= nil and ui.danger.fasthop:GetValue() ~= 0 and input.IsButtonDown(ui.danger.fasthop:GetValue()) and not gui.Reference("Menu"):IsActive() then
        -- initial jump + bhop
        ucmd.buttons = f < 2 and (f == 0 and ucmd.buttons - 4 or (f == 1 and ucmd.buttons - 2 or ucmd.buttons)) or (n and ucmd.buttons - 6 or ucmd.buttons);
        local isTouchingGround = bit.band(entities.GetLocalPlayer():GetPropInt("m_fFlags"), 1) ~= 0;

        gui.SetValue("misc.fakelag.factor", isTouchingGround and 8 or 4 )

        if isTouchingGround then
            if aa == nil then
                aa = gui.GetValue("rbot.antiaim.base");
                gui.SetValue("rbot.antiaim.base", "0.0 \"Off\"")
            end
            ucmd.viewangles = EulerAngles(ucmd.viewangles.x, isTouchingGround and engine.GetViewAngles().y + 135 or ucmd.viewangles.y, ucmd.viewangles.z);
        end;

        if aa ~= nil and not isTouchingGround then
            gui.SetValue("rbot.antiaim.base", aa)
            aa = nil
        end

        f, n = f + 1, isTouchingGround;

        gui.SetValue("misc.strafe.air", not isTouchingGround);
    end;
end);
--[[Fast Bhop Dangerzone End]]--

--[[Button Switching Legit - Rage]]--
local pressed = false;

callbacks.Register("Draw", function()
    if key:GetValue() ~= 0 then
        if input.IsButtonPressed(key:GetValue()) then
 pressed=true;
 elseif (pressed and input.IsButtonReleased(key:GetValue())) then
 pressed=false;
 if gui.GetValue("rbot.master") then
 gui.SetValue("rbot.master", false)
 gui.SetValue("lbot.master", true)
 else
 gui.SetValue("rbot.master", true)
 gui.SetValue("lbot.master", false)
 end
 end
 end
end)
--[[Button Swwitching Legit - Rage End]]--

--[[Lobby Troll]]--
local m_CreateSession = gui.Button(right_tab2, "Tạo Lobby", function()
panorama.RunScript("FriendsListAPI.ActionInviteFriend('0', '');") end)
m_CreateSession:SetWidth(268)

local m_SpamPopup = gui.Button(right_tab2, "Spam Popup", function()
    for i=1,100 do
        panorama.RunScript("PartyListAPI.SessionCommand('Game::HostEndGamePlayAgain', 'run all xuid ' + MyPersonaAPI.GetXuid());")
    end
end)

local m_ClosePopups = gui.Button(right_tab2, "Xóa Popups", function()
    panorama.RunScript("UiToolkitAPI.CloseAllVisiblePopups();")
end)
m_ClosePopups:SetPosX(141)
m_ClosePopups:SetPosY(48)
--[[Lobby Troll End]]--

--[[Spin lobby]]--
local startspin = gui.Button(right_tab4, "Start Spin", function() 
    panorama.RunScript([[
        var ItemPreviewPanel = $.GetContextPanel().FindChildTraverse("JsMainmenu_Vanity");

        if (ItemPreviewPanel != null) {
            ItemPreviewPanel.SetSceneRotation(0, 15, 0);
        }
    ]]);
end);

local stopspin = gui.Button(right_tab4, "Stop Spin", function() 
    panorama.RunScript([[
        var ItemPreviewPanel = $.GetContextPanel().FindChildTraverse("JsMainmenu_Vanity");

        if (ItemPreviewPanel != null) {
            ItemPreviewPanel.SetSceneRotation(0, 0, 0);
        }
    ]]);
end);
stopspin:SetPosX(141)
stopspin:SetPosY(0)
--[[Spin lobby End]]--

--[[RAINBOW HUD START]]--
local color = 1
local time = globals.CurTime()
local orig = client.GetConVar( "cl_hud_color" )
local function RainbowHud()
    if rainbowcheckbox:GetValue() then
        client.Command( "cl_hud_color " .. color, true )
        if globals.CurTime() - rainbowslider:GetValue() >= time then
            color = color + 1
            time = globals.CurTime()
        end
        if color > 9 then color = 1 end
    else
        client.Command( "cl_hud_color " .. orig, true )
    end
end
callbacks.Register( "Draw", function()
    RainbowHud()
end)
--[[RAINBOW HUD END]]--

--[[RanksWin]]--
local w,h = draw.GetScreenSize()

local IN_SCOREBOARD = false

local ranks = {
"Silver 1",
"Silver 2",
"Silver 3",
"Silver 4",
"Silver Elite",
"Silver Elite Master",

"GOLD NOVA 1",
"GOLD NOVA 2",
"GOLD NOVA 3",
"GOLD NOVA Master",

"MASTER GUARDIAN 1",
"MASTER GUARDIAN 2",
"MASTER GUARDIAN ELITE",
"DISTINGUISHED MASTER GUARDIAN",

"LEGENDARY EAGLE",
"LEGENDARY EAGLE MASTER",
"SUPREME MASTER FIRST CLASS",
"GLOBAL ELITE"
}

local font = draw.CreateFont("Tahoma", 14, 300)

callbacks.Register("CreateMove", function(cmd)
local IN_SCORE = bit.lshift(1, 16)
IN_SCOREBOARD = bit.band(cmd.buttons, IN_SCORE) == IN_SCORE
end)

callbacks.Register("Draw", function()
if not engine.GetServerIP() then return end

if not engine.GetServerIP():gmatch("=[A:") then return end

if not gui.Reference("menu"):IsActive() and not IN_SCOREBOARD then return end

local y = h/2

for i, v in next, entities.FindByClass("CCSPlayer") do
if v:GetName() ~= "GOTV" and entities.GetPlayerResources():GetPropInt("m_iPing", v:GetIndex()) ~= 0 then
local index = v:GetIndex()
local rank_index = entities.GetPlayerResources():GetPropInt("m_iCompetitiveRanking", index)
local wins = entities.GetPlayerResources():GetPropInt("m_iCompetitiveWins", index)
local rank = ranks[rank_index] or "Unranked"
draw.SetFont(font)
draw.Color(0,255,255,255)
draw.Text(5, y, v:GetName()..": "..rank.." Wins: "..wins)
y = y + 15
end
end
end)
--[[RanksWin End]]--

--[[DOOR SPAM]]--
local switch = false
callbacks.Register( "CreateMove", function(cmd)
    if doorspam:GetValue() ~= 0 then
        if input.IsButtonDown(doorspam:GetValue()) then
            if switch then client.Command("+use", true)
            else client.Command("-use", true) end
            switch = not switch
        else
            if not switch then client.Command("-use", true) end
        end
    end
end )
--[[DOOR SPAM END]]--

--[[Chat VoteRevealer]]--
local c_hud_chat =
    ffi.cast("unsigned long(__thiscall*)(void*, const char*)", mem.FindPattern("client.dll", "55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39 77 28"))(
    ffi.cast("unsigned long**", ffi.cast("uintptr_t", mem.FindPattern("client.dll", "B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 5D 08")) + 1)[0],
    "CHudChat"
)

local ffi_print_chat = ffi.cast("void(__cdecl*)(int, int, int, const char*, ...)", ffi.cast("void***", c_hud_chat)[0][27])

function client.PrintChat(msg)
    ffi_print_chat(c_hud_chat, 0, 0, " " .. msg)
end

    callbacks.Register(
        "DispatchUserMessage",
        function(um)
            local lp = entities.GetLocalPlayer()
            if not (gui.GetValue("misc.master") and on:GetValue() and lp) then
                return
            end

            local team = lp:GetTeamNumber()
            local clr = team == 2 and "\09" or team == 3 and "\10" or "\01"
            if um:GetID() == 46 then
                local type = um:GetInt(3)
                local type_name =
                    type == 0 and "\07kick player " or type == 1 and " Change map " or type == 6 and "\04Surrender" or
                    type == 13 and "\07Call a timeout"

                client.PrintChat(
                    "[" .. clr .. "Vote launch\01] " .. client.GetPlayerNameByIndex(um:GetInt(2)) .. " wants to " .. type_name .. um:GetString(5)
                )
            end

            local results = um:GetID() == 47 and "\06Passed" or um:GetID() == 48 and "\02Failed"
            local _ = results and client.PrintChat("[" .. clr .. "Vote result\01] " .. results)
        end
    )

    client.AllowListener("vote_cast")

    callbacks.Register(
        "FireGameEvent",
        function(e)
            local lp = entities.GetLocalPlayer()
            if not (gui.GetValue("misc.master") and on:GetValue() and lp) then
                return
            end

            if e:GetName() and e:GetName() == "vote_cast" then
                local team = lp:GetTeamNumber()
                local option = e:GetInt("vote_option")
                local results = option == 0 and "\06YES" or option == 1 and "\07NO" or "?"

                client.PrintChat(
                    "[" ..
                        (team == 2 and "\09" or team == 3 and "\10" or "\01") ..
                            "Vote option\01] " .. client.GetPlayerNameByIndex(e:GetInt("entityid")) .. " " .. results
                )
            end
        end
    )
end)()
--[[Chat VoteRevealer End]]--

--[[Watermark]]--
--render
rect = function( x, y, w, h, col )
    draw.Color( col[1], col[2], col[3], col[4] );
    draw.FilledRect(x, y, x + w, y + h)
end

gradient = function( x, y, w, h, col1, col2, is_vertical )
    rect( x, y, w, h, col1 );

    local r, g, b = col2[1], col2[2], col2[3];

    if is_vertical then
        for i = 1, h do
            local a = i / h * 255;
            rect( x, y + i, w, 1, { r, g, b, a } );
        end
    else
        for i = 1, w do
            local a = i / w * 255;
            rect( x + i, y, 1, h, { r, g, b, a } );
        end
    end
end

local handler_variables = 
{
    weapon_group =  {pistol = {2, 3, 4, 30, 32, 36, 61, 63}, 
                     sniper = {9}, 
                     scout = {40}, 
                     hpistol = {1, 64}, 
                     smg = {17, 19, 23, 24, 26, 33, 34}, 
                     rifle = {60, 7, 8, 10, 13, 16, 39}, 
                     shotgun = {25, 27, 29, 35}, 
                     asniper = {38, 11}, 
                     lmg = {28, 14},
                     zeus = {31}
                    }, 
    fps = 0,
    ping = 0,
    server_ip = 0,
    tickrate_updated = false,
    tickrate = client.GetConVar("sv_maxcmdrate"),
    server = "",
    user_name = cheat.GetUserName(),
    local_entity,
}

--script variable 
local color_r, color_g, color_b, color_a;
local mouseX, mouseY, x, y, dx, dy, w, h = 0, 0, 128, 290, 0, 0, 60, 60;
local shouldDrag = false;
local font = draw.CreateFont("Verdana", 12, 12);
local topbarSize = 23;
local imgRGBA, imgWidth, imgHeight = common.DecodePNG( svgData );
local texture = draw.CreateTexture( imgRGBA, imgWidth, imgHeight );

local function handlers()
    --visuals
    color_r, color_g, color_b, color_a = ui_color:GetValue()
    handler_variables.fps = 1 / globals.AbsoluteFrameTime()

    --entities
    handler_variables.local_entity = entities.GetLocalPlayer()

    --local info
    if handler_variables.local_entity then
        handler_variables.is_scoped = handler_variables.local_entity:GetPropBool("m_bIsScoped")

        handler_variables.ping = entities:GetPlayerResources():GetPropInt("m_iPing", client.GetLocalPlayerIndex())
        
        handler_variables.server_ip = engine.GetServerIP()

        if handler_variables.server_ip == "loopback" then
            handler_variables.server = "localhost"
        elseif string.find(handler_variables.server_ip, "A") then
            handler_variables.server = "valve"    
        else
            handler_variables.server = handler_variables.server_ip
        end

        if not handler_variables.tickrate_updated then
            handler_variables.tickrate = client.GetConVar("sv_maxcmdrate")
            handler_variables.tickrate_updated = true
        end
    else
        handler_variables.tickrate_updated = false
    end
end

local function getWeaponGroup()
    if not handler_variables.local_entity or not not handler_variables.local_entity:IsAlive() then
        return "shared"
    end

    --get current weapon group
    local current_weapon_group = "shared"

    for group_name, group_weapons in pairs(weapon_group) do
        for weapon_id = 1, #group_weapons, 1 do

            local local_weapon_id = handler_variables.local_entity:GetWeaponID()

            if local_weapon_id == group_weapons[weapon_id] then
                current_weapon_group = group_name

                break
            end
        end
    end

    return current_weapon_group
end

local function drawRectFill(r, g, b, a, x, y, w, h, texture)
    if (texture ~= nil) then
        draw.SetTexture(texture);
    else
        draw.SetTexture(texture);
    end
    draw.Color(r, g, b, a);
    draw.FilledRect(x, y, x + w, y + h);
end

local function dragFeature()
    if input.IsButtonDown(1) then
        mouseX, mouseY = input.GetMousePos();

        if shouldDrag then
            x = mouseX - dx;
            y = mouseY - dy;
        end

        if mouseX >= x and mouseX <= x + w and mouseY >= y and mouseY <= y + h then
            shouldDrag = true;
            dx = mouseX - x;
            dy = mouseY - y;
        end
    else
        shouldDrag = false;
    end
end

local function drawOutline(r, g, b, a, x, y, w, h, howMany)
    for i = 1, howMany do
        draw.Color(r, g, b, a);
        draw.OutlinedRect(x - i, y - i, x + w + i, y + h + i);
    end
end

local function drawWatermark()
    if not watermark:GetValue()  then
        return
    end
 
    local divider = ' | ';
    local cheatName = 'gamesense';

    local watermarkText = cheatName .. divider .. handler_variables.user_name .. divider .. "delay: " ..  handler_variables.ping .. "ms" .. divider .. "fps: " .. string.format("%0.1f", handler_variables.fps)

    draw.SetFont(font);
    local w, h = draw.GetTextSize(watermarkText);
    local weightPadding, heightPadding = 20, 13;
    local watermarkWidth = weightPadding + w;
    local start_x, start_y = draw.GetScreenSize();
    start_x, start_y = start_x - watermarkWidth - 0, start_y * 0.0125;

    draw.Color(0, 0, 0, 150);
    draw.FilledRect(start_x - 10, start_y, start_x + watermarkWidth - 20, start_y -2 + h + heightPadding );
 
    draw.Color(0, 0, 0, 255)
    draw.Text(start_x + weightPadding /2+4 - 20, start_y + heightPadding / 2 - 1, watermarkText );
 
    draw.Color(255,255,255,255);
    draw.Text(start_x + weightPadding / 2+4 - 20, start_y + heightPadding / 2 - 1, watermarkText );
 
    draw.Color(color_r, color_g, color_b, color_a, 255);
    draw.FilledRect(start_x - 10, start_y, start_x + watermarkWidth - 20, start_y +2);
end

callbacks.Register("Draw", function()
    handlers()

    if not handler_variables.local_entity or not handler_variables.local_entity:IsAlive() then return end

    drawWatermark()
end)
--[[Watermark End]]--

--[[Miscellaneous]]--
client.Command("+right", true)
client.Command("+left", true)
client.Command("snd_menumusic_volume 30", true)
--[[Miscellaneous End]]--

--[Engine Radar]]--
callbacks.Register('CreateMove', function()
	local isEngineRadarOn = EngineRadar:GetValue() and 1 or 0

	for _, Player in ipairs(entities.FindByClass('CCSPlayer')) do
		Player:SetProp('m_bSpotted', isEngineRadarOn)
	end
end)
--[Engine Radar End]]--

--[Force Crosshair]]--
client.AllowListener('item_equip')
callbacks.Register('FireGameEvent', function(e)
	if not ForceCrosshair:GetValue() or e:GetName() ~= 'item_equip' then
		if not client.GetConVar('weapon_debug_spread_show') == '3' then
			client.SetConVar('weapon_debug_spread_show', 0, true)
		end
		return
	end

	local LocalPlayerIndex = client.GetLocalPlayerIndex()
	local PlayerIndex = client.GetPlayerIndexByUserID( e:GetInt('userid') )
	local WeaponType = e:GetInt('weptype')

	if LocalPlayerIndex == PlayerIndex then
		if WeaponType == 5 then
			client.SetConVar('weapon_debug_spread_show', 3, true)
		end
	end
end)
--[Force Crosshair End]]--

--[Recoil Crosshair]]--
local function CrosshairRecoil()
	if RecoilCrosshair:GetValue() and not gui.GetValue("rbot.master") then
		client.SetConVar("cl_crosshair_recoil", 1, true)
	else
		client.SetConVar("cl_crosshair_recoil", 0, true)
	end
end
--[Recoil Crosshair End]]--

--[Inventory Unlocker]]--
local function UnlockInventoryAccess()
        panorama.RunScript([[
        LoadoutAPI.IsLoadoutAllowed = () => {
                return true;
        };
        ]])
end
local function LockInventoryAccess()
        panorama.RunScript([[
        LoadoutAPI.IsLoadoutAllowed = () => {
                return false;
        };
        ]])
end
callbacks.Register("Draw", function()
    if UnlockInvAccess:GetValue() == true then
        UnlockInventoryAccess()
    else
        LockInventoryAccess()
    end
end)
--[Inventory Unlocker End]]--

--[Message Events]]--
local ranks = {"S1","S2","S3","S4","SE","SEM","GN1","GN2","GN3","GNM","MG1","MG2","MGE","DMG","LE","LEM","SMFC","GE",}
local numbers = {"1","2","3","4","5","6",}
local responses = {"Yes - definitely.","It is decidedly so.","Without a doubt.","Reply hazy, try again.","Ask again later.","Better not tell you now.","My sources say no.","Outlook not so good.","Very doubtful.",}
local results = {"won the coinflip!","lost the coinflip!",}
local gaydar = {"is gay!","is not gay!",}
local anime = {
    {
        "⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄",
        "⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄",
        "⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄",
        "⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄",
        "⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰",
        "⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤",
        "⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗",
        "⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄",
        "⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄",
        "⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄",
        "⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄",
        "⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄",
        "⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄",
        "⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴",
        "⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿",
    },
    {
        "⡿⠋⠄⣀⣀⣤⣴⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣌⠻⣿⣿",
        "⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠹⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠹",
        "⣿⣿⡟⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡛⢿⣿⣿⣿⣮⠛⣿⣿⣿⣿⣿⣿⡆",
        "⡟⢻⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣣⠄⡀⢬⣭⣻⣷⡌⢿⣿⣿⣿⣿⣿",
        "⠃⣸⡀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠈⣆⢹⣿⣿⣿⡈⢿⣿⣿⣿⣿",
        "⠄⢻⡇⠄⢛⣛⣻⣿⣿⣿⣿⣿⣿⣿⣿⡆⠹⣿⣆⠸⣆⠙⠛⠛⠃⠘⣿⣿⣿⣿",
        "⠄⠸⣡⠄⡈⣿⣿⣿⣿⣿⣿⣿⣿⠿⠟⠁⣠⣉⣤⣴⣿⣿⠿⠿⠿⡇⢸⣿⣿⣿",
        "⠄⡄⢿⣆⠰⡘⢿⣿⠿⢛⣉⣥⣴⣶⣿⣿⣿⣿⣻⠟⣉⣤⣶⣶⣾⣿⡄⣿⡿⢸",
        "⠄⢰⠸⣿⠄⢳⣠⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣼⣿⣿⣿⣿⣿⣿⡇⢻⡇⢸",
        "⢷⡈⢣⣡⣶⠿⠟⠛⠓⣚⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⢸⠇⠘",
        "⡀⣌⠄⠻⣧⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠛⠛⠛⢿⣿⣿⣿⣿⣿⡟⠘⠄⠄",
        "⣷⡘⣷⡀⠘⣿⣿⣿⣿⣿⣿⣿⣿⡋⢀⣠⣤⣶⣶⣾⡆⣿⣿⣿⠟⠁⠄⠄⠄⠄",
        "⣿⣷⡘⣿⡀⢻⣿⣿⣿⣿⣿⣿⣿⣧⠸⣿⣿⣿⣿⣿⣷⡿⠟⠉⠄⠄⠄⠄⡄⢀",
        "⣿⣿⣷⡈⢷⡀⠙⠛⠻⠿⠿⠿⠿⠿⠷⠾⠿⠟⣛⣋⣥⣶⣄⠄⢀⣄⠹⣦⢹⣿",
    },
    {
        "⠄⠄⠄⢀⣤⣾⣿⡟⠋⠄⠄⠄⣀⡿⠄⠊⠄⠄⠄⠄⠄⠄⢸⠇⠄⢀⠃⠙⣿⣿",
        "⣤⠒⠛⠛⠛⠛⠛⠛⠉⠉⠉⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⠄⢀⠊⠄⠄⠈⢿",
        "⣿⣠⠤⠴⠶⠒⠶⠶⠤⠤⣤⣀⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⠃⠄⠂⣀⣀⣀⡀⠄",
        "⡏⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠈⠙⠂⠄⠄⠄⠄⠄⠄⢀⢎⠐⠛⠋⠉⠉⠉⠉⠛",
        "⡇⠄⠄⠄⣀⡀⠄⠄⠄⢀⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠎⠁⠄⠄⠄⠄⠄⠄⠄⠄",
        "⡧⠶⣿⣿⣿⣿⣿⣿⠲⠦⣭⡃⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⡀⠄⠄⠄⠄⠄⠄",
        "⡇⠄⣿⣿⣿⣿⣿⣿⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢰⣾⣿⣿⣿⡟⠛⠶⠄",
        "⡇⠄⣿⣿⣿⣿⣿⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣼⣿⣿⣿⣿⡇⠄⠄⢀",
        "⡇⠄⢿⣿⣿⣿⣿⣷⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⡇⠄⠄⢊",
        "⢠⠄⠈⠛⠛⠛⠛⠋⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢿⣿⣿⣿⡦⠁⠄⠄⣼",
        "⢸⠄⠈⠉⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠉⠉⠄⠄⠄⠄⢰⣿",
        "⢸⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠁⠉⠄⢸⣿",
        "⠄⣆⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⣀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢸⣿",
        "⠄⢿⣷⣶⣄⡀⠄⠄⠄⠄⠄⠄⠉⠉⠉⠉⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⣴⣿⣿",
        "⠄⢸⣿⣿⣿⣿⣷⣦⣤⣀⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣀⣠⣤⣶⣿⣿⣿⣿⣿",
    },
    {
        "⣿⠟⣽⣿⣿⣿⣿⣿⢣⠟⠋⡜⠄⢸⣿⣿⡟⣬⢁⠠⠁⣤⠄⢰⠄⠇⢻⢸",
        "⢏⣾⣿⣿⣿⠿⣟⢁⡴⡀⡜⣠⣶⢸⣿⣿⢃⡇⠂⢁⣶⣦⣅⠈⠇⠄⢸⢸",
        "⣹⣿⣿⣿⡗⣾⡟⡜⣵⠃⣴⣿⣿⢸⣿⣿⢸⠘⢰⣿⣿⣿⣿⡀⢱⠄⠨⢸",
        "⣿⣿⣿⣿⡇⣿⢁⣾⣿⣾⣿⣿⣿⣿⣸⣿⡎⠐⠒⠚⠛⠛⠿⢧⠄⠄⢠⣼",
        "⣿⣿⣿⣿⠃⠿⢸⡿⠭⠭⢽⣿⣿⣿⢂⣿⠃⣤⠄⠄⠄⠄⠄⠄⠄⠄⣿⡾",
        "⣼⠏⣿⡏⠄⠄⢠⣤⣶⣶⣾⣿⣿⣟⣾⣾⣼⣿⠒⠄⠄⠄⡠⣴⡄⢠⣿⣵",
        "⣳⠄⣿⠄⠄⢣⠸⣹⣿⡟⣻⣿⣿⣿⣿⣿⣿⡿⡻⡖⠦⢤⣔⣯⡅⣼⡿⣹",
        "⡿⣼⢸⠄⠄⣷⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣕⡜⡌⡝⡸⠙⣼⠟⢱⠏",
        "⡇⣿⣧⡰⡄⣿⣿⣿⣿⡿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣋⣪⣥⢠⠏⠄",
        "⣧⢻⣿⣷⣧⢻⣿⣿⣿⡇⠄⢀⣀⣀⡙⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠂⠄⠄",
        "⢹⣼⣿⣿⣿⣧⡻⣿⣿⣇⣴⣿⣿⣿⣷⢸⣿⣿⣿⣿⣿⣿⣿⣿⣰⠄⠄⠄",
        "⣼⡟⡟⣿⢸⣿⣿⣝⢿⣿⣾⣿⣿⣿⢟⣾⣿⣿⣿⣿⣿⣿⣿⣿⠟⠄⡀⡀",
        "⣿⢰⣿⢹⢸⣿⣿⣿⣷⣝⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠉⠄⠄⣸⢰⡇",
        "⣿⣾⣹⣏⢸⣿⣿⣿⣿⣿⣷⣍⡻⣛⣛⣛⡉⠁⠄⠄⠄⠄⠄⠄⢀⢇⡏⠄",
    },
    {
        "⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⣠⣤⣶⣶",
        "⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⢰⣿⣿⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣀⣀⣾⣿⣿⣿⣿",
        "⣿⣿⣿⣿⣿⡏⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿",
        "⣿⣿⣿⣿⣿⣿⠀⠀⠀⠈⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠁⠀⣿",
        "⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠙⠿⠿⠿⠻⠿⠿⠟⠿⠛⠉⠀⠀⠀⠀⠀⣸⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣴⣿⣿⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⢰⣹⡆⠀⠀⠀⠀⠀⠀⣭⣷⠀⠀⠀⠸⣿⣿⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠈⠉⠀⠀⠤⠄⠀⠀⠀⠉⠁⠀⠀⠀⠀⢿⣿⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⢾⣿⣷⠀⠀⠀⠀⡠⠤⢄⠀⠀⠀⠠⣿⣿⣷⠀⢸⣿⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⡀⠉⠀⠀⠀⠀⠀⢄⠀⢀⠀⠀⠀⠀⠉⠉⠁⠀⠀⣿⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿",
        "⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿",
    },
    {
        "⣿⡇⣿⣿⣿⠛⠁⣴⣿⡿⠿⠧⠹⠿⠘⣿⣿⣿⡇⢸⡻⣿⣿⣿⣿⣿⣿⣿",
        "⢹⡇⣿⣿⣿⠄⣞⣯⣷⣾⣿⣿⣧⡹⡆⡀⠉⢹⡌⠐⢿⣿⣿⣿⡞⣿⣿⣿",
        "⣾⡇⣿⣿⡇⣾⣿⣿⣿⣿⣿⣿⣿⣿⣄⢻⣦⡀⠁⢸⡌⠻⣿⣿⣿⡽⣿⣿",
        "⡇⣿⠹⣿⡇⡟⠛⣉⠁⠉⠉⠻⡿⣿⣿⣿⣿⣿⣦⣄⡉⠂⠈⠙⢿⣿⣝⣿",
        "⠤⢿⡄⠹⣧⣷⣸⡇⠄⠄⠲⢰⣌⣾⣿⣿⣿⣿⣿⣿⣶⣤⣤⡀⠄⠈⠻⢮",
        "⠄⢸⣧⠄⢘⢻⣿⡇⢀⣀⠄⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠄⢀",
        "⠄⠈⣿⡆⢸⣿⣿⣿⣬⣭⣴⣿⣿⣿⣿⣿⣿⣿⣯⠝⠛⠛⠙⢿⡿⠃⠄⢸",
        "⠄⠄⢿⣿⡀⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⡾⠁⢠⡇⢀",
        "⠄⠄⢸⣿⡇⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⣫⣻⡟⢀⠄⣿⣷⣾",
        "⠄⠄⢸⣿⡇⠄⠈⠙⠿⣿⣿⣿⣮⣿⣿⣿⣿⣿⣿⣿⣿⡿⢠⠊⢀⡇⣿⣿",
        "⠒⠤⠄⣿⡇⢀⡲⠄⠄⠈⠙⠻⢿⣿⣿⠿⠿⠟⠛⠋⠁⣰⠇⠄⢸⣿⣿⣿",
        "⠄⠄⠄⣿⡇⢬⡻⡇⡄⠄⠄⠄⡰⢖⠔⠉⠄⠄⠄⠄⣼⠏⠄⠄⢸⣿⣿⣿",
        "⠄⠄⠄⣿⡇⠄⠙⢌⢷⣆⡀⡾⡣⠃⠄⠄⠄⠄⠄⣼⡟⠄⠄⠄⠄⢿⣿⣿",
    },
    {
        "⣿⢸⣿⣿⣿⣿⣿⢹⣿⣿⣿⣿⣿⢿⣿⡇⡇⣿⣿⡇⢹⣿⣿⣿⣿⣿⣿⠄⢸⣿",
        "⡟⢸⣿⣿⣭⣭⡭⣼⣶⣿⣿⣿⣿⢸⣧⣇⠇⢸⣿⣿⠈⣿⣿⣿⣿⣿⣿⡆⠘⣿",
        "⡇⢸⣿⣿⣿⣿⡇⣻⡿⣿⣿⡟⣿⢸⣿⣿⠇⡆⣝⠿⡌⣸⣿⣿⣿⣿⣿⡇⠄⣿",
        "⢣⢾⣾⣷⣾⣽⣻⣿⣇⣿⣿⣧⣿⢸⣿⣿⡆⢸⣹⣿⣆⢥⢛⡿⣿⣿⣿⡇⠄⣿",
        "⣛⡓⣉⠉⠙⠻⢿⣿⣿⣟⣻⠿⣹⡏⣿⣿⣧⢸⣧⣿⣿⣨⡟⣿⣿⣿⣿⡇⠄⣿",
        "⠸⣷⣹⣿⠄⠄⠄⠄⠘⢿⣿⣿⣯⣳⣿⣭⣽⢼⣿⣜⣿⣇⣷⡹⣿⣿⣿⠁⢰⣿",
        "⠄⢻⣷⣿⡄⢈⠿⠇⢸⣿⣿⣿⣿⣿⣿⣟⠛⠲⢯⣿⣒⡾⣼⣷⡹⣿⣿⠄⣼⣿",
        "⡄⢸⣿⣿⣷⣬⣽⣯⣾⣿⣿⣿⣿⣿⣿⣿⣿⡀⠄⢀⠉⠙⠛⠛⠳⠽⠿⢠⣿⣿",
        "⡇⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢄⣹⡿⠃⠄⠄⣰⠎⡈⣾⣿⣿",
        "⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣭⣽⣖⣄⣴⣯⣾⢷⣿⣿⣿",
        "⣧⠸⣿⣿⣿⣿⣿⣿⠯⠊⠙⢻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⣾⣿⣿⣿",
        "⣿⣦⠹⣿⣿⣿⣿⣿⠄⢀⣴⢾⣼⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣾⣿⣿⣿⣿",
        "⣿⣿⣇⢽⣿⣿⣿⡏⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⡿⣿⣛⣻⠿⣟⣼⣿⣿⣿⣿⢃",
        "⣿⣿⣿⡎⣷⣽⠻⣇⣿⣿⣿⡿⣟⣵⣿⣟⣽⣾⣿⣿⣿⣿⢯⣾⣿⣿⣿⠟⠱⡟",
        "⣿⣿⣿⣿⢹⣿⣿⢮⣚⡛⠒⠛⢛⣋⣶⣿⣿⣿⣿⣿⣟⣱⠿⣿⣿⠟⣡⣺⢿",
    }
}

local timer = timer or {}
local timers = {}

function timer.Create(name, delay, times, func)
    table.insert(timers, {["name"] = name, ["delay"] = delay, ["times"] = times, ["func"] = func, ["lastTime"] = globals.RealTime()})
end

function timer.Remove(name)
    for k,v in pairs(timers or {}) do
        if (name == v["name"]) then table.remove(timers, k) end
    end
end

callbacks.Register("DispatchUserMessage", function(msg)
    if msg:GetID() == 6 then
        local index = msg:GetInt(1)
		local message = msg:GetString(4,1)
        local message2 = msg:GetString(4,1):lower()
        local m = string.match
        local ec = enable_chatcmds:GetValue()
        local ecf = enable_coin_flip:GetValue()

        local player_name = client.GetPlayerNameByIndex(index)
        local lp = entities.GetLocalPlayer()
        local lp_name = client.GetPlayerInfo( lp:GetIndex() )[ "Name" ]
        local number = numbers[math.random(#numbers)]
        local response = responses[math.random(#responses)]
        local result = results[math.random(#results)]
        local thingy = gaydar[math.random(#gaydar)]

        if m(message2, "!roll") and enable_chatcmds:GetValue() and enable_roll:GetValue() then
            timer.Create("message_delay", 0.7, 1, function()
                msg = ('%s rolled a %s'):format(player_name, number)
                client.ChatSay(msg)
            end)
        end

        if m(message2, "!8ball") and enable_chatcmds:GetValue() and enable_8ball:GetValue() then
            timer.Create("message_delay", 0.7, 1, function()
                client.ChatSay("❽: " .. response)
            end)
        end

        if m(message2, "!gay") and enable_chatcmds:GetValue() and enable_gaydar:GetValue() then
            timer.Create("message_delay", 0.7, 1, function()
                msg = ('%s %s'):format(player_name, thingy)
                client.ChatSay(msg)
            end)
        end

        if m(message2, "!cf") and ec and ecf or m(message2, "!flip") and ec and ecf or m(message2, "!coin flip") and ec and ecf or m(message2, "!coinflip") and ec and ecf then
            timer.Create("message_delay", 0.7, 1, function()
                msg = ('%s %s'):format(player_name, result)
                client.ChatSay(msg)
            end)
        end

        if m(message, "!anime") and ec and enable_anime:GetValue() then
            random = math.random(1, #anime)
            for i=1, #anime[random] do
                timer.Create("message_delay", 0.7, i, function()
                    client.ChatSay(anime[random][i])
                end)
            end
        end

        if m(message, "!ranks") and ec and enable_ranks:GetValue() then
            for i, v in next, entities.FindByClass("CCSPlayer") do
                if v:GetName() ~= "GOTV" and entities.GetPlayerResources():GetPropInt("m_iPing", v:GetIndex()) ~= 0 then
                    local index = v:GetIndex()
                    local rank_index = entities.GetPlayerResources():GetPropInt("m_iCompetitiveRanking", index)
                    local wins = entities.GetPlayerResources():GetPropInt("m_iCompetitiveWins", index)
                    local rank = ranks[rank_index] or "no rank"
                    if ranks_mode:GetValue() == 0 then 
                        timer.Create("message_delay", 1, i, function()
                            client.ChatTeamSay(v:GetName() .. " has " .. wins .. " wins " .. "(" .. rank .. ")")
                        end)

                    elseif ranks_mode:GetValue() == 1 then 
                        timer.Create("message_delay", 1, i, function()
                            client.ChatSay(v:GetName() .. " has " .. wins .. " wins " .. "(" .. rank .. ")")
                        end)
                    end
                end
            end
        end
    end
end)

callbacks.Register("Draw", function()
    for k,v in pairs(timers or {}) do
  
        if (v["times"] <= 0) then table.remove(timers, k) end
      
        if (v["lastTime"] + v["delay"] <= globals.RealTime()) then
            timers[k]["lastTime"] = globals.RealTime()
            timers[k]["times"] = timers[k]["times"] - 1
            v["func"]()
        end  
    end
end)
--[Message Events End]]--

--[Draw Image]]--
local function OnUnload()
client.Command("toggleconsole", true)
  client.Command('echo "bye, hope u comeback without this lua again :3', true)
  client.Command('echo "----------------------------------------------', true)
	client.Command('echo "⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄"', true)
	client.Command('echo "⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄"', true)
	client.Command('echo "⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄"', true)
	client.Command('echo "⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄"', true)
	client.Command('echo "⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰"', true)
	client.Command('echo "⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤"', true)
	client.Command('echo "⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗"', true)
	client.Command('echo "⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄"', true)
	client.Command('echo "⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄"', true)
	client.Command('echo "⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄"', true)
	client.Command('echo "⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄"', true)
	client.Command('echo "⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄"', true)
	client.Command('echo "⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄"', true)
	client.Command('echo "⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴"', true)
	client.Command('echo "⣿⣿⣿⣶⣶⣮⣥⣒⠄⠄⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿"', true)

	if clantagset == 1 then
		set_clantag("", "")
	end
end
--[Draw Image End]]--

--[[Lua Callbacks & Listeners]]--
callbacks.Register('FireGameEvent', for_chatsay);
callbacks.Register('FireGameEvent', for_throwsay);
callbacks.Register('CreateMove', CrosshairRecoil);
callbacks.Register("Draw", UnlockInventory);
callbacks.Register("Unload", OnUnload);
callbacks.Register("Draw",Render);
callbacks.Register("FireGameEvent",EventHook);
